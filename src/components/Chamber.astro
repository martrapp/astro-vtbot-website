---

---

<script>
	import { TRANSITION_AFTER_SWAP, TRANSITION_BEFORE_SWAP } from 'astro:transitions/client';
	import { elementsWithStyleProperty } from 'node_modules/astro-vtbot/components/css';
	import { deriveCSSSelector } from 'node_modules/astro-vtbot/components/derive-css-selector';
	import type { TransitionBeforeSwapEvent } from 'astro:transitions/client';

	declare global {
		interface Window {
			__vtbot: {
				framed?: boolean;
			};
		}
	}

	type Modus = 'bypass' | 'slow-motion' | 'control' | 'compare';

	let outerViewTransition: ViewTransition | undefined;
	function mayViewTransition(fun: () => void, name: string, disabled = false) {
		if (outerViewTransition) console.warn(name + ': OuterView Transition already in progress');

		if (
			disabled ||
			document.documentElement.classList.contains('vtbot-vt-active') ||
			outerViewTransition ||
			!document.startViewTransition
		) {
			fun();
		} else {
			outerViewTransition = document.startViewTransition(fun);
			outerViewTransition.finished.finally(() => (outerViewTransition = undefined));
		}
	}

	let viewTransition: ViewTransition | undefined;
	let animations: Animation[] | undefined;
	let animationDuration = 0;

	async function retrieveViewTransitionAnimations(doc: Document) {
		animations = [];

		const set = new WeakSet();
		let growing = true;
		while (growing) {
			growing = false;
			doc.getAnimations().forEach((a) => {
				//@ts-ignore
				if (
					!set.has(a) &&
					//@ts-ignore
					a.effect?.pseudoElement?.startsWith('::view-transition') &&
					a.playState !== 'finished'
				) {
					set.add(a);
					animations?.push(a);
					a.pause();
					a.currentTime = 0;
					growing = true;
				}
			});
			growing && (await new Promise((r) => setTimeout(r)));
		}
		animationDuration = ~~animations.reduce(
			(acc, anim) =>
				Math.max(acc, (anim.effect?.getComputedTiming().activeDuration?.valueOf() as number) ?? 0),
			0
		);

		animations!.map((a) => {
			//@ts-ignore
			const name = a.effect.pseudoElement;
			const styles = window.getComputedStyle(doc.documentElement, name);
			console.log(name, styles.transform, '|', styles.inset);
		});
	}

	function sloMoPlay() {
		animations?.forEach(
			(a) => (
				(a.playbackRate =
					1.0 /
					Math.max(
						0.000001,
						parseFloat(document.querySelector<HTMLSpanElement>('#vtbot-ui-tsf')?.innerText ?? '1.0')
					)),
				a.playState === 'paused' && a.play()
			)
		);
	}

	function controlledPlay() {
		document.querySelector<HTMLSpanElement>('#vtbot-ui-controller-max')!.innerText =
			animationDuration + ' ms';
		document.querySelector<HTMLSpanElement>('#vtbot-ui-progress')!.innerText = '0';
		const controller = document.querySelector<HTMLInputElement>('#vtbot-ui-controller')!;
		controller.max = '' + animationDuration;
		//controller.value = '0';
		controller.disabled = false;
		const controller2 = document.querySelector<HTMLInputElement>('#vtbot-ui-controller2')!;
		controller2.max = '' + animationDuration;
		//controller2.value = '0';
		controller2.disabled = false;
		control();
	}

	function viewTransitionNameOfAnimation(animation: Animation) {
		//@ts-ignore
		return animation.effect?.pseudoElement?.replace(
			/::view-transition-(new|old|group)\((.*)\)/,
			'$2'
		);
	}
	function control() {
		if (animations) {
			const selectedTime = parseInt(
				document.querySelector<HTMLSpanElement>('#vtbot-ui-progress')!.innerText
			);
			const otherTime = parseInt(
				document.querySelector<HTMLSpanElement>('#vtbot-ui-progress2')!.innerText
			);
			const selectedElements = new Set<string>();
			document
				.querySelectorAll<HTMLLIElement>('#vtbot-ui-names li.selected')
				.forEach((li) => selectedElements.add(li.innerText));
			animations.forEach((animation) => {
				const name = viewTransitionNameOfAnimation(animation);
				animation.currentTime = selectedElements.has(name) ? selectedTime : otherTime;
			});
		}
	}

	function pauseAnimations(doc: Document) {
		setStyles(
			doc,
			`
	::view-transition-group(*),
	::view-transition-new(*),
	::view-transition-old(*) {
		animation-play-state: paused;
		animation-delay: 0s;
	}`
		);
	}

	function setStyles(doc: Document, styles: string, suffix = '') {
		const id = 'vtbot-adopted-sheet' + (suffix ? '-' + suffix : '');
		doc.getElementById(id)?.remove();
		doc.documentElement.offsetHeight;
		styles && doc.head.insertAdjacentHTML('beforeend', `<style id="${id}">${styles}</style>`);
	}

	function unleashAllAnimations(doc: Document) {
		doc.querySelector('#vtbot-adopted-sheet')?.remove();
		animations?.forEach((a) => {
			try {
				a.finish();
			} catch (e) {
				console.log(e, a, a.effect?.getComputedTiming());
			}
		});
	}

	const glow = [
		// Keyframes
		{ boxShadow: '0 0  0px green' },
		{ boxShadow: '0 0 50px green' },
		{
			boxShadow: '0 0 100px green',
			display: 'inline-block',
			minWidth: '20px',
			minHeight: '20px',
			backgroundColor: 'lightgreen',
		},
		{ boxShadow: '0 0 50px green' },
		{ boxShadow: '0 0  0px green' },
	];
	const glowKeyFrames = `
	@keyframes glow {
		0% { box-shadow: 0 0   0px green; }
		25% { box-shadow: 0 0 50px green; }
		50% {
			box-shadow: 0 0 100px green;
			min-width: 20px;
			min-height: 20px;
			background-color: lightgreen;
		}
		75% { box-shadow: 0 0 50px green; },
		100% { box-shadow: 0 0 0px green; },
	}`;

	function glowPseudo(doc: Document, name: string) {
		setStyles(
			doc,
			`${glowKeyFrames}
		::view-transition-image-pair(${name}) {
			animation: glow 0.5s
		}
		`,
			'glow'
		);
	}
	function unframe(doc: Document) {
		setStyles(doc, '');
	}
	function frame(doc: Document) {
		setStyles(
			doc,
			`
	::view-transition-old(*) {
		border: 3px dashed darkblue;
	}
	::view-transition-new(*) {
		border: 3px dashed darkolivegreen;
	}
	::view-transition-group(*),
	[data-vtbot-transition-name] {
		border: 1px dotted darkgoldenrod;
	}
	:root::view-transition {
		position: absolute;
		inset: 0;
	}
`
		);
	}

	function updateAnimationNames() {
		const oldNames = new Set<string>();
		const newNames = new Set<string>();

		animations?.forEach((animation) => {
			//@ts-ignore
			const pseudo = animation.effect.pseudoElement;
			const match = pseudo?.match(/::view-transition-(new|old|group)\((.*)\)/);
			if (match) {
				const name = match[2];
				if (match[1] === 'new') newNames.add(name);
				if (match[1] === 'old') oldNames.add(name);
			}
		});
		return updateNames(oldNames, newNames);
	}

	function addFrames(doc: Document, show: boolean) {
		show ? frame(doc) : unframe(doc);
	}

	if (window === window.parent || !window.parent?.__vtbot?.framed) {
		window.__vtbot ??= {};
		window.__vtbot.framed = true;

		window.addEventListener('pageshow', () => {
			const docTitle = document.title;

			setTimeout(async () => {
				const root = document.documentElement;
				const page = (await (await fetch('http://127.0.0.1:4321/bench/')).text()).replace(
					'<iframe id="vtbot-main-frame" src="/"></iframe>',
					`<iframe id="vtbot-main-frame" style="opacity: 0" src="${location.href}"></iframe>`
				);
				setOrientation();
				root.innerHTML = page;

				document.title = '⛑️ ' + docTitle;
				root.dataset.vtbotModus = '';
				const mainFrame = document.querySelector<HTMLIFrameElement>('#vtbot-main-frame')!;
				await new Promise((r) => (mainFrame.onload = r));
				const frameDocument = mainFrame.contentDocument!;

				if (!document.startViewTransition) {
					document.querySelector('#vtbot-ui-messages')!.innerHTML = `
					<h4>You are &hellip;</h4>
					<p>&hellip; in the <b>Engine Room</b><img style="width:4em; float:right" src="/favicon.svg" /> deep down at the bottom of <b>The Bag!</b></p>
					<p>I'm sorry!</p><p>Native view transitions are required to make the Test Chamber work, but they are not supported by this browser.</p>
					<p>Sadly have to give up.</p>`;
					document
						.querySelectorAll('#vtbot-ui-modi, #vtbot-ui-filter, #vtbot-ui-names, #vtbot-ui-info')
						.forEach((e) => e.remove());
					return;
				}
			const original = frameDocument.startViewTransition;
				frameDocument.startViewTransition = (cb: () => void) =>{
					addFrames(frameDocument, false);
					return original.call(frameDocument, cb);
				}

				updateNames(markTransitions(frameDocument));
				initPanelHandlers(mainFrame);
				initGrabbing();
				mainFrame.animate([{ opacity: 0 }, { opacity: 1 }], {
					duration: 50,
					fill: 'forwards',
				});
				frameDocument.addEventListener(TRANSITION_BEFORE_SWAP, beforeSwap);
				frameDocument.addEventListener(TRANSITION_AFTER_SWAP, () => {
					history.replaceState(history.state, '', mainFrame.contentWindow!.location.href);
				});
				frameDocument.addEventListener('click', innerClick);
			}, 500);
		});
	}

	function beforeSwap(e: TransitionBeforeSwapEvent) {
		const root = document.documentElement;
		const mainFrame = document.querySelector<HTMLIFrameElement>('#vtbot-main-frame')!;
		const frameDocument = mainFrame.contentDocument!;
		const mode: Record<Modus, () => void> = {
			bypass: () => {},
			'slow-motion': sloMoPlay,
			control: controlledPlay,
			compare: () => {},
		};
		viewTransition = e.viewTransition;
		e.newDocument.documentElement.style.colorScheme = document.documentElement.style.colorScheme;
		root.classList.add('vtbot-vt-active');
		const modus = root.dataset.vtbotModus as Modus;
		if (modus && modus !== 'bypass') {
			pauseAnimations(e.newDocument);
			e.viewTransition.ready.then(async () => {
				await retrieveViewTransitionAnimations(frameDocument);
				addFrames(
					frameDocument,
					document.querySelector<HTMLInputElement>('#vtbot-ui-styled')!.checked
				);
				updateAnimationNames();
				mode[modus]();
			});
		}
		e.viewTransition.finished.finally(() => {
			viewTransition = undefined;
			root.classList.remove('vtbot-vt-active');
			unleashAllAnimations(document);
			animations = undefined;
			updateNames(markTransitions(frameDocument));
		});
	}

	function innerClick(e: MouseEvent) {
		if (!document.documentElement.classList.contains('vtbot-vt-active')) {
			const target = e.target as HTMLElement;
			const vt = target.closest<HTMLElement>('[data-vtbot-transition-name]');
			if (vt) {
				const name = vt.dataset.vtbotTransitionName;
				document.querySelectorAll<HTMLLIElement>('#vtbot-ui-names li').forEach((li) => {
					if (li.innerText === name) {
						li.click();
					}
				});
			}
		} else {
			animations?.filter(a=>{
				//@ts-ignore
				const {target, pseudoElement} = a.effect;
				const {top, right, bottom, left, width, height, transform, transformOrigin} = getComputedStyle(target, pseudoElement)
				console.log(pseudoElement, left, top, right, bottom, width, height, transform, transformOrigin)
			})
		}
	}

	function markTransitions(doc: Document) {
		doc
			.querySelectorAll('.vtbot-highlight')
			.forEach((el) => el.classList.remove('vtbot-highlight'));
		doc
			.querySelectorAll('.vtbot-highlight-multiple')
			.forEach((el) => el.classList.remove('vtbot-highlight-multiple'));
		doc
			.querySelectorAll('[data-vtbot-transition-name]')
			.forEach((el) => el.removeAttribute('data-vtbot-transition-name'));

		const els = elementsWithStyleProperty(doc, 'view-transition-name');
		els.forEach((set, key) => {
			if (key === 'none') {
				els.delete(key);
			} else {
				set.forEach((el) => {
					//el.classList.add('vtbot-highlight');
					//if (set.size > 1) el.classList.add('vtbot-highlight-multiple');
					(el as HTMLElement).dataset.vtbotTransitionName = key;
				});
			}
		});
		return new Set(els.keys());
	}

	function updateControl() {
		if (
			document.documentElement.classList.contains('vtbot-vt-active') &&
			document.documentElement.dataset.vtbotModus === 'control'
		) {
			control();
		}
	}

	function initPanelHandlers(frame: HTMLIFrameElement) {
		frame.addEventListener('load', () => {
			location.href = frame.contentWindow!.location.href;
		});
		document.querySelector('#vtbot-ui-turn')!.addEventListener('click', switchOrientation);
		document.querySelector('#vtbot-ui-modi ul')!.addEventListener('change', updateModus);

		document.querySelector('#vtbot-ui-names ol')!.addEventListener('click', (e) => {
			if (e.target instanceof HTMLElement) {
				const targetLi = e.target.closest('li');
				if (targetLi) {
					mayViewTransition(() => {
						const name = targetLi.innerText;
						highlightInFrame(name, frame);
						highlightNames(name);
						const elem = frame.contentDocument?.querySelector(
							`[data-vtbot-transition-name="${name}"]`
						);
						writeSelectorToClipboard(elem);
					}, 'names');
				}
			}
			updateControl();
		});

		document.querySelector('#vtbot-ui-filter ul')!.addEventListener('change', refreshNames);
		document
			.querySelector('#vtbot-ui-filter input[type="text"]')!
			.addEventListener('input', refreshNames);
		document.querySelector('#vtbot-ui-filter button')!.addEventListener('click', resetFilter);
		document.querySelector('#vtbot-ui-names button')!.addEventListener('click', resetSelected);

		document
			.querySelector('#vtbot-ui-styled')
			?.addEventListener('change', (e) =>
				addFrames(frame.contentDocument!, (e.target as HTMLInputElement).checked)
			);

		const sloMo = document.querySelector('#vtbot-ui-slo-mo')!;
		const sloMoTsf = document.querySelector<HTMLInputElement>('#vtbot-ui-tsf')!;
		sloMo.addEventListener('input', (e) => {
			if (e.target instanceof HTMLInputElement) {
				const value = (Math.exp(parseInt(e.target.value, 10) / 100) - 100) / 100 + 1 - 0.14;
				sloMoTsf.innerText = `${value.toFixed(1)}`;
				sloMoPlay();
			}
		});

		document
			.querySelectorAll('#vtbot-ui-control-exit, #vtbot-ui-control-play')
			.forEach((e) => e.addEventListener('click', exitViewTransition));
		const controller = document.querySelector<HTMLInputElement>('#vtbot-ui-controller')!;
		const progress = document.querySelector<HTMLInputElement>('#vtbot-ui-progress')!;
		controller.addEventListener('input', (e) => {
			if (e.target instanceof HTMLInputElement) {
				progress.innerText = '' + ~~e.target.value;
				control();
			}
		});
		const controller2 = document.querySelector<HTMLInputElement>('#vtbot-ui-controller2')!;
		const progress2 = document.querySelector<HTMLInputElement>('#vtbot-ui-progress2')!;
		controller2.addEventListener('input', (e) => {
			if (e.target instanceof HTMLInputElement) {
				progress2.innerText = '' + ~~e.target.value;
				control();
			}
		});

		window.addEventListener('keyup', function (e) {
			if (e.key === 'Escape') {
				if (document.documentElement.classList.contains('vtbot-vt-active')) {
					exitViewTransition();
				} else {
					window.location.reload();
				}
			}
		});
	}

	function writeSelectorToClipboard(elem?: Element | null) {
		if (elem) {
			navigator.clipboard.writeText(
				`inspect(top.document.querySelector("#vtbot-main-frame").contentDocument.querySelector("${deriveCSSSelector(elem)}"))`
			);
			document.querySelector<HTMLInputElement>('#vtbot-ui-info')!.innerHTML = `<h4>Info</h4>
							<p>DevTools selector '<b><code>${deriveCSSSelector(elem)}</code></b>' copied to clipboard. Paste to DevTools console to further inspect the element.</p>`;
		} else {
			navigator.clipboard.writeText(
				`inspect(top.document.querySelector("#vtbot-main-frame").contentDocument.querySelector(":root"))`
			);
			document.querySelector<HTMLInputElement>('#vtbot-ui-info')!.innerHTML = `<h4>Info</h4>
							<p>DevTools selector '<b><code>:root</code></b>' copied to clipboard. Paste to DevTools console, then expand the element and its <code>::view-transition</code> pseudo element.</p>`;
		}
	}
	function updateNames(leftTransitionNames: Set<string>, rightTransitionNames?: Set<string>) {
		//navigator.clipboard.writeText("");
		document.querySelector('#vtbot-ui-info')!.innerHTML = '';
		document.querySelectorAll('#vtbot-ui-names li').forEach((li) => li.remove());
		document.querySelector<HTMLElement>('#vtbot-ui-names h4')!.innerText = rightTransitionNames
			? 'Animations'
			: 'Elements w/ View Transition Names';

		const list = document.querySelector('#vtbot-ui-names > ol')!;
		const names = [...new Set([...leftTransitionNames, ...(rightTransitionNames ?? [])])].sort();
		names.forEach((name, idx) => {
			const li = document.createElement('li');
			li.innerText = name;
			if (rightTransitionNames && leftTransitionNames.has(name)) {
				li.classList.add('left');
			}
			if (rightTransitionNames?.has(name)) {
				li.classList.add('right');
			}
			li.style.viewTransitionName = `vtbot-name-${idx}`;
			list.appendChild(li);
		});
		document.querySelector<HTMLElement>('#vtbot-ui-filter ul')!.style.display = rightTransitionNames
			? 'block'
			: 'none';
		refreshNames();
		return names;
	}

	function highlightInFrame(name: string, frame: HTMLIFrameElement) {
		const doc = frame.contentDocument;
		if (doc) {
			/*
			doc
				.querySelectorAll('[data-vtbot-transition-name]')
				.forEach((el) => el.classList.remove('selected'));
			doc
				.querySelectorAll(`[data-vtbot-transition-name='${name}']`)
				.forEach((target) => target.classList.add('selected'));
			*/
			scrollIntoView(doc, name);
		}
	}

	function highlightNames(name: string) {
		const control =
			document.documentElement.dataset.vtbotModus === 'control' &&
			document.querySelector<HTMLElement>('#vtbot-ui-names h4')!.innerText === 'Animations';
		const lis = document.querySelectorAll<HTMLLIElement>('#vtbot-ui-names li');
		let selected: HTMLLIElement | undefined;
		lis.forEach((li) => {
			if (li.innerText === name) {
				li.classList[control ? 'toggle' : 'add']('selected');
				selected = li;
				if (li.style.display === 'none') resetFilter();
			} else {
				if (!control) li.classList.remove('selected');
			}
		});
		selected &&
			selected.scrollIntoView({ behavior: 'instant', block: 'nearest', inline: 'nearest' });
	}

	function scrollIntoView(doc: Document, name: string) {
		if (document.documentElement.classList.contains('vtbot-vt-active')) {
			glowPseudo(doc, name);
		}
		const el = doc.querySelector<HTMLElement>(`[data-vtbot-transition-name="${name}"]`);
		if (el) {
			el.scrollIntoView({ behavior: 'instant', block: 'nearest', inline: 'nearest' });
			const display = window.getComputedStyle(el).display;
			glow[2]!.display = display === 'inline' ? 'inline-block' : display;
			el.animate(glow, { duration: 500, iterations: 1 });
		}
	}

	window.addEventListener('resize', setOrientation);
	function setOrientation() {
		const html = document.documentElement;
		if (
			window.matchMedia('(orientation: landscape)').matches !==
			html.classList.contains('vtbot-ui-column')
		)
			switchOrientation();
	}

	function switchOrientation() {
		// changing the snapshot containing block size skips the transition
		mayViewTransition(() => {
			unleashAllAnimations(document);
			document.documentElement.classList.toggle('vtbot-ui-column');
		}, 'switch orientation');
	}

	function exitViewTransition() {
		viewTransition?.skipTransition();
	}
	function resetFilter() {
		document.querySelector<HTMLInputElement>('#vtbot-ui-filter input[type="text"]')!.value = '';
		document.querySelector<HTMLInputElement>('#vtbot-ui-filter ul input')!.click();
		refreshNames();
	}
	function resetSelected() {
		document
			.querySelectorAll<HTMLInputElement>('#vtbot-ui-names li.selected')
			.forEach((item) => item.classList.remove('selected'));
		updateControl();
	}
	function refreshNames() {
		const names = document.querySelectorAll<HTMLLIElement>('#vtbot-ui-names li');
		const filter = document
			.querySelector<HTMLInputElement>('#vtbot-ui-filter ul input:checked')!
			.id.replace('vtbot-c-', '');
		const fragment = document.querySelector<HTMLInputElement>(
			'#vtbot-ui-filter input[type="text"]'
		)!.value;
		mayViewTransition(() => {
			names.forEach((name) => {
				const style = name.style;
				const classes = name.classList;
				style.display =
					(fragment === '' || name.innerText.includes(fragment)) &&
					(filter === 'all' ||
						(filter === 'both' && classes.contains('right') && classes.contains('left')) ||
						(filter === 'left' && classes.contains('left') && !classes.contains('right')) ||
						(filter === 'right' && classes.contains('right') && !classes.contains('left')))
						? 'list-item'
						: 'none';
				if (visible(name)) {
					classes.remove('invis');
				} else {
					classes.add('invis');
				}
			});
		}, 'refresh names');
	}

	const visible = (el: HTMLElement) => {
		const { top, right, bottom, left, width, height } = el.getBoundingClientRect();
		return (
			false ||
			(width > 0 &&
				height > 0 &&
				window.getComputedStyle(el).visibility !== 'hidden' &&
				top >= 0 &&
				left >= 0 &&
				bottom <= window.innerHeight &&
				right <= window.innerWidth)
		);
	};
	const message: Record<Modus, string> = {
		bypass: `<h4>Bypass</h4><p>Navigation is <b>not intercepted</b>.</p><ol><li>Optional: Examine elements by selecting from the View Transition Name list</li><li>Navigate your page as usual</li></ol>`,
		'slow-motion': `<h4>Slow Motion</h4><ol><li>Use the slider to set a <b>time stretch factor</b></li><li>Press a link on your page to start a view transition and study the <b>slowed down animations!</li></ol>`,
		control: `<h4>Full Control</h4><ol><li>Start a transition</li><li>Select animations</li><li>Move freely through the timeline and concentrate on selected elements and groups.</li></ol>`,
		compare: `<h4>Side-by-side</h4><p>Sometimes you need a clear view of where you're coming from and where you're going!</p><p>Compare the <b>old and new pages side by side</b> and see what morphs where.</p>`,
	};

	let firstModusInteraction = true;

	function updateModus() {
		const root = document.documentElement;
		const checked = document.querySelector<HTMLInputElement>('#vtbot-ui-modi ul input:checked');
		if (checked) {
			const modus = checked.id.replace('vtbot-m-', '') as Modus;
			if (modus !== root.dataset.vtbotModus) {
				mayViewTransition(() => {
					root.dataset.vtbotModus = modus;
					exitViewTransition();
					if (modus !== 'compare')
						document.querySelector<HTMLInputElement>('#vtbot-ui-filter ul input')!.click();
					if (modus === 'slow-motion') {
						attachFrameToggle('#vtbot-ui-slow-motion');
					}
					if (modus === 'control') {
						attachFrameToggle('#vtbot-ui-control');
					}
					document.querySelector<HTMLInputElement>('#vtbot-ui-messages')!.innerHTML =
						message[modus];

					if (firstModusInteraction) {
						firstModusInteraction = false;
						document
							.querySelector('#vtbot-ui-panel')
							?.insertAdjacentElement(
								'afterbegin',
								document.querySelector<HTMLInputElement>('#vtbot-ui-modi')!
							);
					}
				}, 'update-modus');
			}
		}
	}

	function attachFrameToggle(divId: string) {
		const styled = document.querySelector('#vtbot-ui-styled')?.parentElement;
		const div = document.querySelector(divId);
		if (styled && div && styled.parentElement !== div)
			div.insertAdjacentElement('beforeend', styled);
	}

	function initGrabbing() {
		const startDragging = (e: Event) => {
			root.classList.add('dragging');
			root.querySelector<HTMLIFrameElement>('#vtbot-main-frame')!.style.pointerEvents = 'none';
			if (e.cancelable) e.preventDefault();
		};

		const drag = (e: MouseEvent | TouchEvent) => {
			if (root.classList.contains('dragging')) {
				const clientX = (e instanceof TouchEvent ? e.touches[0]?.clientX : e.clientX) ?? 0;
				const clientY = (e instanceof TouchEvent ? e.touches[0]?.clientY : e.clientY) ?? 0;

				if (root.classList.contains('vtbot-ui-column')) {
					root.style.setProperty(
						'--vtbot-panel-width',
						`calc(max(188px, 100vw - ${Math.max(100, clientX + 1)}px))`
					);
				} else {
					root.style.setProperty(
						'--vtbot-panel-height',
						`calc(max(204px, 100vh - ${Math.max(100, clientY + 1)}px))`
					);
				}
			}
		};

		const stopDragging = () => {
			if (root.classList.contains('dragging')) {
				root.classList.remove('dragging');
				root.querySelector<HTMLIFrameElement>('#vtbot-main-frame')!.style.pointerEvents = 'auto';
			}
		};

		const root = document.documentElement;

		const divider = document.querySelector('#divider')!;
		divider.addEventListener('mousedown', startDragging);
		divider.addEventListener('touchstart', startDragging, { passive: false });

		document.addEventListener('mousemove', drag);
		document.addEventListener('touchmove', drag);

		document.addEventListener('mouseup', stopDragging);
		document.addEventListener('touchend', stopDragging);
	}
</script>
