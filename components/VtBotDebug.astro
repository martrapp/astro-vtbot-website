---
import VtBotDebug1 from './VtBotDebug1.astro';
export interface Props {
	production?: boolean;
}
const TAG = 'vtbot-debug';
const { production = false } = Astro.props;
const active = import.meta.env.DEV || production;
---

{active && <meta name={TAG} content="true" />}

{active && <VtBotDebug1 />}
<script>
	// start of "late" part in (defered loaded) module script
	import {
		isTransitionBeforePreparationEvent,
		isTransitionBeforeSwapEvent,
		type TransitionBeforePreparationEvent,
		type TransitionBeforeSwapEvent,
		TRANSITION_BEFORE_PREPARATION,
		TRANSITION_AFTER_PREPARATION,
		TRANSITION_BEFORE_SWAP,
		TRANSITION_AFTER_SWAP,
		TRANSITION_PAGE_LOAD,
		supportsViewTransitions,
	} from 'astro:transitions/client';
	import { deriveCSSSelector, elementsWithStyleProperty } from './css';

	const enabled = () => !!document.querySelector('meta[name="vtbot-debug"]');
	const PREFIX = '[vtbot-debug]';

	/*
	 * address/content surrogate
	 */
	let addressCounter = 0;
	const mem = new WeakMap();
	const doc = (obj: Document) => {
		const units = ['B', 'kB', 'MB'];
		const humanReadable = (n: number) => {
			let i = 0;
			while ((n /= 1024) > 1 && i++ < units.length);
			return `${(n * 1024).toFixed(1)} ${units[i]}`;
		};
		const a = mem.get(obj) ?? `${++addressCounter}`;
		const html = obj.documentElement.outerHTML;
		mem.set(obj, a);
		return `@${a} (${humanReadable(html.length)})`;
	};

	const logWithStyle = (s: string) => {
		// @ts-ignore
		const _vtbot_debug = window._vtbot_debug;
		const css: string[] = [];
		s = s.replaceAll('**', '%c');
		const count = (s.match(/%c/g) || []).length / 2;
		for (let i = 0; i < count; i++) {
			css.push('display: inline-block; border: dotted 1pt gray; padding: 0 4pt;font-weight: 800');
			css.push('font-weight: normal');
		}
		console.log(s, ...css);
	};

	/*
	 * log a property of the event
	 */
	async function delta(e: Record<string, any>, prop: string, deltaOnly = false) {
		// @ts-ignore
		const _vtbot_debug = window._vtbot_debug;
		const bold = (s: string) => `**${s}**`;
		let deref = (x: any) => x;
		let print = (x: any) => x;
		let value = (x: any) => x;

		if (prop === 'to' || prop === 'from') {
			deref = (x) => x?.href;
			print = deref;
		} else if (prop === 'newDocument') {
			print = doc;
			value = doc;
		} else if (prop === 'swap' || prop === 'loader') {
			print = (x) => {
				const s = x ? x.toString() : '(null)';
				const max = 60;
				return s.length < max ? s : s.substring(0, max - 4) + ' ...';
			};
		}

		let different = () => value(deref(_vtbot_debug.capture[prop])) !== value(deref(e[prop]));

		if (different()) {
			logWithStyle(
				`${PREFIX} ${prop} changed from ${bold(print(_vtbot_debug.capture[prop]))} to ${bold(
					print(e[prop])
				)}`
			);
		} else if (!deltaOnly) {
			logWithStyle(`${PREFIX} ${prop}: ${bold(print(e[prop]))}`);
		}
	}

	/*
	 * Capture the event properties
	 */
	const doCapture = (e: Event) => {
		// @ts-ignore
		window._vtbot_debug.capture = {
			...e,
			type: e.type,
			cancelable: e.cancelable,
			defaultPrevented: e.defaultPrevented,
			event: e,
		};
	};

	/*
	 * log the properties of the event
	 */
	function logProperties(
		e: TransitionBeforePreparationEvent | TransitionBeforeSwapEvent,
		deltaOnly = false
	) {
		delta(e, 'type', deltaOnly);
		delta(e, 'cancelable', deltaOnly);
		delta(e, 'defaultPrevented', deltaOnly);
		delta(e, 'from', deltaOnly);
		delta(e, 'to', deltaOnly);
		delta(e, 'direction', deltaOnly);
		delta(e, 'navigationType', deltaOnly);
		delta(e, 'info', deltaOnly);
		delta(e, 'newDocument', deltaOnly);
		if (isTransitionBeforePreparationEvent(e)) {
			delta(e, 'formData', deltaOnly);
			delta(e, 'loader', deltaOnly);
		}
		if (isTransitionBeforeSwapEvent(e)) {
			delta(e, 'swap', deltaOnly);
		}
		doCapture(e);
	}

	/*
	 * Log beforePreparation
	 */
	function beforePreparation(preparationEvent: Event) {
		if (enabled()) {
			if (isTransitionBeforePreparationEvent(preparationEvent)) {
				console.groupCollapsed(`${PREFIX} Properties of the ${preparationEvent.type} event`);
				logProperties(preparationEvent);
				console.groupEnd();
				const originalLoader = preparationEvent.loader;
				preparationEvent.loader = async () => {
					console.log(`${PREFIX} before execution of loader()`);
					await originalLoader();
					logProperties(preparationEvent, true);
					console.log(`${PREFIX} after execution of loader()`);
				};
				doCapture(preparationEvent);
			} else {
				console.log('not a TransitionBeforePreparationEvent');
			}
		}
	}

	const toCSSSelectorMap = (map: Map<string, Set<Element>> | undefined, where: string) => {
		const result = new Map<string, string>();
		if (map) {
			map.forEach((set, key) => {
				if (set.size === 1) {
					result.set(key, deriveCSSSelector([...set][0]));
				} else if (supportsViewTransitions && (set?.size ?? 0) > 1) {
					logWithStyle(
						`${PREFIX} view-transition-name **${key}** is not unique in ${where} document\n`
					);
				}
			});
		}
		return result;
	};
	const logTransitions = (
		originalMap: Map<string, string> | undefined,
		swapEvent: TransitionBeforeSwapEvent
	) => {
		if (originalMap === undefined) return;

		// @ts-ignore
		const bold = (s: string) => `**${s}**`;
		const map = elementsWithStyleProperty('view-transition-name');
		map.set('root', (map.get('root') ?? new Set()).add(document.documentElement));
		const newMap = toCSSSelectorMap(map, 'new');
		let i = 0;

		console.groupCollapsed(
			`${PREFIX} Transitions from ${swapEvent.from.pathname} to ${swapEvent.to.pathname}`
		);
		new Set([...originalMap.keys(), ...newMap.keys()]).forEach((name) => {
			const oldSelector = originalMap.get(name);
			const newSelector = newMap.get(name);

			logWithStyle(
				`[ transition] ${++i} "${bold(name)}" from ${bold(
					oldSelector ?? '(nowhere)'
				)} --to-> ${bold(newSelector ?? '(nowhere)')}`
			);
		});

		console.groupEnd();
	};

	const moduleScripts = new Set();
	const recordScripts = () =>
		[...document.scripts].forEach(
			(script) => script.type === 'module' && script.src && moduleScripts.add(script.src)
		);

	function logScripts() {
		let modules = '';
		const toExecute = [...document.scripts].filter(
			(s) =>
				s.dataset.astroExec !== '' &&
				(!s.type || s.type === 'module' || s.type === 'text/javascript') &&
				(s.type !== 'module' ||
					!s.src ||
					!moduleScripts.has(s.src) ||
					((modules += s.src + ' '), false))
		);
		if (toExecute.length > 0) {
			let i = 0;
			logWithStyle(
				`${PREFIX} **Scripts** that execute between astro:after-swap and astro:page-load: (${toExecute.length})`
			);
			toExecute.forEach((script) => {
				script.type === 'module' && script.src && moduleScripts.add(script.src);
				let s = `${PREFIX} ${++i}. `;
				for (const attribute of script.attributes) {
					s += `${attribute.name}="${attribute.value}" `;
				}
				logWithStyle(
					s + (script.textContent ?? '').replace(/\n|\s+/g, ' ').substring(0, 60) + '...'
				);
			});
			if (modules) {
				logWithStyle(
					`${PREFIX} **Modules scripts** can't be re-executed until next full page reload: ` +
						modules
				);
			}
		}
	}

	/*
	 * Log swap
	 */
	function beforeSwap(swapEvent: Event) {
		if (enabled()) {
			recordScripts();
			if (isTransitionBeforeSwapEvent(swapEvent)) {
				console.groupCollapsed(`${PREFIX} Properties of the ${swapEvent.type} event`);
				logProperties(swapEvent);
				console.groupEnd();

				if (supportsViewTransitions) {
					const map = elementsWithStyleProperty('view-transition-name');
					map.set('root', (map.get('root') ?? new Set()).add(document.documentElement));
					// @ts-ignore
					window._vtbot_debug.originalMap = toCSSSelectorMap(map, 'old');
				}
				const originalSwap = swapEvent.swap;
				swapEvent.swap = async () => {
					console.log(`${PREFIX} before execution of swap()`);
					originalSwap();
					// @ts-ignore
					logProperties(window._vtbot_debug.capture.event, true);
					console.log(`${PREFIX} after execution of swap()`);
					console.log(`${PREFIX} %o`, document.documentElement);
					// @ts-ignore
					window._vtbot_debug.savedSwapEvent = swapEvent;
				};
				doCapture(swapEvent);
				swapEvent.viewTransition.updateCallbackDone.then(
					() => console.log(`${PREFIX} resolve viewTransition.updateCallbackDone`),
					(error: any) =>
						console.log(`${PREFIX} reject viewTransition.updateCallbackDone with`, error)
				);
				swapEvent.viewTransition.ready.then(
					() => console.log(`${PREFIX} resolve viewTransition.ready`),
					(error: any) => console.log(`${PREFIX} reject viewTransition.ready with`, error)
				);
				swapEvent.viewTransition.finished.then(
					() => {
						console.log(`${PREFIX} resolve viewTransition.finished`);
					},
					(error: any) => {
						console.log(`${PREFIX} reject viewTransition.finished with`, error);
					}
				);
			} else {
				console.log('not a TransitionBeforeSwapEvent');
			}
		}
	}

	const afterSwap = (e: Event) => {
		if (enabled()) {
			// @ts-ignore
			const event = window._vtbot_debug.capture.event;
			logProperties(event, true);
			console.log(`${PREFIX} Event handler for ${e.type}`);
			// @ts-ignore
			const _vtbot_debug = window._vtbot_debug;
			if (supportsViewTransitions) {
				logTransitions(_vtbot_debug.originalMap, _vtbot_debug.savedSwapEvent);
			} else {
				logWithStyle(`${PREFIX} morphing transitions are not supported by this browser`);
			}
			logScripts();
		}
	};

	/*
	 * Register the "late" handlers
	 */
	// register as late as possible (= in pageshow event) to be the last handler in the chain
	window.addEventListener('pageshow', () => {
		console.log(
			`${PREFIX} Registering event listeners for '${TRANSITION_BEFORE_PREPARATION}', '${TRANSITION_AFTER_PREPARATION}', '${TRANSITION_BEFORE_SWAP}', '${TRANSITION_AFTER_SWAP}' and '${TRANSITION_PAGE_LOAD}'`
		);
		document.addEventListener(TRANSITION_BEFORE_PREPARATION, beforePreparation);
		document.addEventListener(TRANSITION_AFTER_PREPARATION, (e) => {
			if (enabled()) {
				// @ts-ignore
				logProperties(window._vtbot_debug.capture.event, true);
				console.log(`${PREFIX} Event handler for ${e.type}`);
			}
		});
		document.addEventListener(TRANSITION_BEFORE_SWAP, beforeSwap);
		document.addEventListener(TRANSITION_AFTER_SWAP, afterSwap);
		document.addEventListener(TRANSITION_PAGE_LOAD, (e) => {
			if (enabled()) {
				// @ts-ignore
				logProperties(window._vtbot_debug.capture.event, true);
				console.log(`${PREFIX} Event handler for ${e.type}`);
			}
		});
		/*
			document.addEventListener('animationstart', (e) => {
				if (enabled() && e instanceof AnimationEvent) {
					console.log(`${PREFIX} ${e.animationName} started on ${e.target}`);
				}
			});
			document.addEventListener('animationend', (e) => {
				if (enabled()) {
					console.log(`${PREFIX} %o`, e);
				}
			});
			*/
	});
</script>
